<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Nâ€‘Up (3Ã—2 / 3Ã—3)</title>


<link rel="stylesheet" href="style1.css">


<link rel="icon" href="icon.png" type="image/xicon" />









</head>
<body>


<!-- Popup -->
<div id="downloadPopup" style="display:none;">
    <div id="popupBox">
        <h2>ðŸŽ‰ PDF Downloaded!</h2>
        <p>Your file is ready. Click below to open.</p>
        <button id="openPdfBtn">Open PDF</button>
        <button id="closePopupBtn">Close</button>
    </div>
</div>





















  
 <div class="container">
   




  <h3>6/9 Pages on Sheet</h3>

  <input type="file" id="pdfInput" accept="application/pdf" />
  <select id="layout">
    <option value="3x2">6 Pages (Landscape)</option>
    <option value="3x3">9 Pages (Portrait)</option>
  </select>
  <button id="processBtn">Process & Download</button>

  <!-- pdf-lib from CDN -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <script>
    const input = document.getElementById('pdfInput');
    const layoutSelect = document.getElementById('layout');
    const btn = document.getElementById('processBtn');

    btn.addEventListener('click', () => {
      if (!input.files || !input.files[0]) {
        alert('Select a PDF first.');
        return;
      }
      processPDF(input.files[0], layoutSelect.value)
        .catch(err => {
          console.error(err);
          alert('Error: ' + err.message);
        });
    });

    async function processPDF(file, layout) {
      const arrayBuf = await file.arrayBuffer();

      // Load original PDF and create output PDF
      const srcPdf = await PDFLib.PDFDocument.load(arrayBuf);   // [web:20]
      const outPdf = await PDFLib.PDFDocument.create();         // [web:27]

      // A4 size (points) â€“ 595Ã—842 portrait
      const is32 = layout === '3x2';
      const pageWidth  = is32 ? 842 : 595;  // landscape vs portrait
      const pageHeight = is32 ? 595 : 842;

      const cols = 3;
      const rows = is32 ? 2 : 3;

      const margin = 20;
      const gap = 10;

      const cellW = (pageWidth  - margin * 2 - gap * (cols - 1)) / cols;
      const cellH = (pageHeight - margin * 2 - gap * (rows - 1)) / rows;

      const pageCount = srcPdf.getPageCount();

      // For 3Ã—2 layout, rotate logical positions 7â€“12 by 180Â°
      // (counting left->right, top->bottom across all sheets)
      const rotatePositions = new Set([7, 8, 9, 10, 11, 12]);

      let sheetIndex = 0;
      for (let base = 0; base < pageCount; base += rows * cols, sheetIndex++) {
        const sheet = outPdf.addPage([pageWidth, pageHeight]);

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const idx = base + r * cols + c;
            if (idx >= pageCount) continue;

            // Embed original page into the new PDF
            const [embedded] = await outPdf.embedPdf(arrayBuf, [idx]);  // [web:20]

            const pw = embedded.width;
            const ph = embedded.height;

            const scale = Math.min(cellW / pw, cellH / ph);
            const drawW = pw * scale;
            const drawH = ph * scale;

            const cellX = margin + c * (cellW + gap);
            const cellY = pageHeight - margin - (r + 1) * cellH - r * gap;

            // center inside cell
            const x = cellX + (cellW - drawW) / 2;
            const y = cellY + (cellH - drawH) / 2;

            // 1â€‘based logical position over all sheets
            const pos = sheetIndex * (rows * cols) + (r * cols + c + 1);

            if (is32 && rotatePositions.has(pos)) {
              // Keep same rectangle but rotate 180Â° around lower-left:
              // shift origin by width+height, then rotate.
              sheet.drawPage(embedded, {
                x: x + drawW,
                y: y + drawH,
                width: drawW,
                height: drawH,
                rotate: PDFLib.degrees(180)   // [web:27]
              });
            } else {
              sheet.drawPage(embedded, {
                x,
                y,
                width: drawW,
                height: drawH
              });
            }
          }
        }
      }

      const outBytes = await outPdf.save();
      const blob = new Blob([outBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);



lastDownloadedURL = url;   // store for popup open button
showDownloadPopup();       // show celebration popup


      

      const a = document.createElement('a');
      a.href = url;
      a.download = 'n-up-' + layout + '.pdf';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }






let lastDownloadedURL = null;

// Show popup
function showDownloadPopup() {
    const popup = document.getElementById("downloadPopup");
    popup.style.display = "flex";

    // Confetti celebration
    confetti({
        particleCount: 200,
        spread: 80,
        origin: { y: 0.6 }
    });

    // Open PDF button
    if (lastDownloadedURL) {
        document.getElementById("openPdfBtn").onclick = () => {
            window.open(lastDownloadedURL, "_blank");
        };
    }

    // Close popup
    document.getElementById("closePopupBtn").onclick = () => {
        popup.style.display = "none";
    };
}








    
  </script>
</body>
</html>



